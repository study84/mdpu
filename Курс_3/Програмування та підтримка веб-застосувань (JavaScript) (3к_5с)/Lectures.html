<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>513-і, Золотухін Андрій</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/decimal.js/10.4.3/decimal.min.js"></script>
	
	<style>
		body {
			background-color: #555555;
			color: Tan;
		}
	</style>
	
</head>

<body>
    <h1>Програмування та підтримка веб-застосувань (JavaScript) (3к_5с)<br>ЛЕКЦИИ<br>513-і, Золотухін Андрій</h1>	
	<hr>
	
	<details>
		<summary><b>Лекция 1</b></summary>
		<pre>
		"use strict" - Включает строгий режим (strict mode) в JavaScript. Делает код более «строгим» и безопасным: Запрещает использовать несуществующие переменные; Не даёт переопределять зарезервированные слова; Помогает находить ошибки раньше. Рекомендуется всегда писать "use strict"; в начале скрипта.
		
		var a;
		var b = 2;
		let c;
		let d = " any text " ;
		f = 10.5; // не працює в use strict
		var COLOR_RED = "#F00"; // Приймаємо за константу
		COLOR_GREEN = "#0F0"; // Приймаємо за константу
		const myBirthday = '18.04.1982'; // Дійсно константа (тільки нові браузери)
		
		Число "number"
		Рядок «string»
		Булевий (логічний) тип "boolean"
		Спеціальне значення "null"
		Спеціальне значення "undefined"
		Усі об'єктні типи (посилання) « object »
		Функція (посилання на функцію)
		
		Оператор typeof - Визначити тип змінної (возвращает в виде строки)
		typeof undefined // "undefined"
		typeof 0 // "number"
		typeof true // "boolean"
		typeof "foo" // "string"
		typeof {} // "object"
		typeof null // "object"
		typeof function(){} //"function"
		
		let n = 123;
		n = 12.345;
		var a = Number.NaN; Глобальное свойство NaN является значением, представляющим не-число (Not-A-Number).
		let b = Number.NEGATIVE_INFINITY;
		let c = Number.POSITIVE_INFINITY;
		Number.isNaN(x)
		Number.isFinite(x)
		Number.isInteger(x)
		Number.isSafeInteger(x)
		Number.parseFloat() // є глобальна
		Number.parseInt() // є глобальна
		---
		let bigInt = 1234567890123456734567890n;
		
		
		Спеціальне значення null не відноситься до жодного з типів
		Спеціальне значення undefined також стоїть окремо
		
		
		let a = 123;
		let b=a.toString(); // У будь-якому типі є такий метод
		let b1=a.toString(16); // Вказати систему числення
		let c=String(a); // Ясне перетворення (конструктор типу)
		let d=""+a; //операція конкатинації з рядком
		--
		let numberVal=Number("853"); //Явне приведення
		let numberVal2=+"321"; // Через трюк
		let intVal=Number.parseInt("543"); // Приведення до цілого
		let floatVal=Number.parseFloat("5.65"); // приведення суворо до речового

		Діалоги
		result = <b>prompt(title, [default]);</b> // Цей код відображає модальне вікно з текстом, полем для введення тексту та кнопками OK/Скасувати. Користувач може надрукувати щось у полі введення та натиснути OK. Він також може скасувати введення натисканням кнопки «Скасувати» або натиснувши клавішу Esc. Виклик prompt поверне текст, вказаний у полі для введення, або null, якщо введення скасовано користувачем.
		result = <b>confirm(question);</b> //Функція confirm відображає модальне вікно з текстом питання question та двома кнопками: OK та Скасувати.
		
		МАССИВЫ / ARRAY
		let arr = новий Array();
		let arr = новий Array(2); // Чи створимо масив довжиною 2
		let arr = new Array(" Яблуко", "Груша", "і тд");
		let arr = [];
		let fruits = [" Яблуко", "Апельсин", "Слива"];
		let any=[1,”2”, false, undefinit];
		--
		length - размер массива. автоматично оновлюється при зміні масиву. length – його можна перезаписати. Якщо ми вручну збільшимо його, нічого цікавого не станеться. Проте, якщо ми зменшимо його, масив стане коротшим. Цей процес необоротний
		---
		push( X) додає елемент до кінця.
		pop() видаляє останній елемент.
		shift() видаляє елемент на початку, зрушуючи чергу, так що другий елемент стає першим. 
		unshift(X) додає елемент до кінця.		
		
		Перебір елементів
		for (let i = 0; i < arr.length; i++) - звичайний цикл for
		for (let fruit <b>of</b> fruits) - проходить за значеннями
		for (let index <b>in</b> fruits) - проходить за індексами
		
		
		Операції порівняння
		// Типи наводяться автоматично
		let h = 5 <4; // false
		let g=5<"6";// true

		// Небезпека наведення типів
		let l=(""==0); // true
		let z=("1"==true); // true

		//Правильні варіанти
		let l=(""===0); // false
		let z=("1"!==true); // true
		
		
		функція showMessage(from, text)
		{
			if (text === undefined)
			text = 'текст не передано’;
			alert( from + ": " + text );
		}
		
		функція showMessage(from, text)
			{text = text || 'текст не передано';


		function showMessage(from, text = " текст порожній") // Аргументи за замовчуванням Новий синтаксис
		{
		   alert( from + ": " + text );
		}
		
		</pre>
	</details>
	<br>
	
	
	<details>
		<summary><b>Лекция 4. Массивы.</b></summary>
		<pre>
			<a href = 'https://www.youtube.com/watch?v=5BpzTVEq6Bo'>JS Array Methods</a>
			
			arr.splice (index[, deleteCount , elem1, ..., elemN ]) - Видаляються Елементи починаючи з arr [index] і в кількості deleteCount 
			
			arr.slice (start, [end]) - Він повертає новий масив, який копіює елементи, починаючи з індексу start і до end (не включаючи end ).
			
			arr.concat (arg1, arg2...) - створює новий масив, який копіює дані з інших масивів і додаткові значення
			
			arr.indexOf (item, from) – шукає item, починаючи з індексу from, і повертає індекс, у якому було знайдено шуканий елемент, інакше -1.

			arr.lastIndexOf (item, from) – те саме, але шукає справа наліво.

			arr.includes (item, from) – шукає item, починаючи з індексу from, та повертає true, якщо пошук успішний.
			
			arr.forEach (function(item, index, array) {// ... робити щось з item}); // виконує дії над кожним елементом
			
			let result = arr.find(function(item, index, array)
			//
			let arr = [5, 12, 8, 130, 44];
			let result = arr.filter(num => num > 10); // Найдем все элементы больше 10
			console.log(result); // Выведет: [12, 130, 44]
			
			arr.filter ( function ( item , index , array )
			
			arr.map (function(item, index, array)
			let lengths=["Bilbo","Gandalf"," Nazgul "].map(item => item.length);
			
			arr.sort();
			
			arr.reverse();
			
			let arr = [' Вася', 'Петя', 'Маша'];
			let str = arr.join (';');
			
			arr.reduce (function( previousValue , item, index, array);
			let arr = [1, 2, 3, 4, 5];
			let result = arr.reduce(function(accumulator, item) {return accumulator + item;}, 0); // 0 - начальное значение для аккумулятора
			let result = arr.reduce ((sum, current) => sum + current, 0);
		
		</pre>
	</details>
	<br>
	
	
	<details>
		<summary><b>Лекция 2</b></summary>
		<pre>
			function sayHi()
			{
				for (var i = 0; i < arguments.length; i++) // Всі аргументи містяться в колекції arguments
					alert( "Привіт," + arguments [i]);
			}  
			sayHi("Вінні", "П'ятачок");
			
			
			
			function sumAll(...args) { // args - ім'я масиву. Залишкові параметри можуть бути позначені через три точки .... Буквально це означає: «зібери параметри, що залишилися, і поклади їх у масив».
			let sum = 0;
			for (let arg of args)
				sum + = arg;
			return sum;
			}



			let arr = [3, 5, 1];
			alert (Math.max (... arr)); // Оператор … під час виклику "розкриває" масив до списку аргументів.
			
			
			
			var sayHi = function(person) // анонімні функції
			{
				alert(" Привіт ," + person); 
			};
			sayHi('Вася'); 


		
		</pre>
	</details>
	<br>
	
	
	<details>
		<summary><b>Лекция REGEXP</b></summary>
		<pre>
		var regexp = new RegExp("шаблон", "флаги"); - Синтаксис создания регулярного выражения
			
		Как правило, используют более короткую запись (шаблон внутри слешей "/"): Слеши "/" говорят JavaScript о том, что это регулярное выражение
		var regexp = /шаблон/; // без флагов 
		var regexp = /шаблон/gmi; // с флагами gmi (изучим их дальше)
			
			
		Основа регулярного выражения – паттерн
		var str = "Я люблю JavaScript!"; // будем искать в этой строке 
		var regexp = /лю/; 
		alert(str.search(regexp) ); // 2
		.......
		Сравните с обычным поиском: 
		var str = "Я люблю JavaScript!"; 
		var substr = "лю"; 
		alert( str.indexOf(substr) ); // 2
			
			
		Флаги 
		i - Если этот флаг есть, то регэксп ищет независимо от регистра, то есть не различает между А и а.
			var str = "Я люблю JavaScript!"; // будем искать в этой строке 
			alert( str.search( /ЛЮ/ ) ); // -1 
			alert( str.search( /ЛЮ/i ) ); // 2
		g - Если этот флаг есть, то регэксп ищет все совпадения, иначе – только первое. 
		m - Многострочный режим.

		var str = "Люблю регэкспы я, но странною любовью"; 
		alert( str.search( /лю/i ) ); // 0 Он возвращает позицию первого совпадения или -1, если ничего не найдено.
		
		str.match(reg)
		var str = "ОЙ-Ой-ой"; 
		var result = str.match( /ой/i ); 
		alert( result[0] ); // ОЙ  (совпадение) 
		alert( result.index ); // 0 (позиция) 
		alert( result.input ); // ОЙ-Ой-ой (вся поисковая строка)
		...
		Если  часть  шаблона  обозначена  скобками,  то  она  станет  отдельным  элементом массива.
		var str = "javascript - это такой язык"; 
		var result = str.match( /JAVA(SCRIPT)/i ); 
		alert( result[0] ); // javascript (всё совпадение полностью) 
		alert( result[1] ); // script (часть совпадения, соответствующая скобкам) 
		alert( result.index ); // 0 
		alert( result.input ); // javascript - это такой язык 
		...
		str.match(reg) с флагом g При наличии флага g, вызов match возвращает обычный массив из всех совпадений.
		var str = "ОЙ-Ой-ой"; 
		var result = str.match( /ой/ig ); 
		alert( result ); // ОЙ, Ой, ой
		...
		str.match(reg) с флагом g
		var str = "ОЙ-Ой-ой"; 
		var result = str.match( /ой/ig ); 
		alert( result ); // ОЙ, Ой, ой
		
		
		str.split(reg|substr, limit) - Разбивает  строку  в  массив  по  разделителю  –  регулярному  выражению  regexp  или подстроке substr.
		alert('12-34-56'.split('-')) // [12, 34, 56]
		alert('12-34-56'.split(/-/)) // [12, 34, 56]
		
		
		str.replace(reg, str|func) - Швейцарский нож для работы со строками, поиска и замены любого уровня сложности
		alert('12-34-56'.replace("-", ":")) // 12:34-56 При вызове со строкой замены replace всегда заменяет только первое совпадение
		Чтобы  заменить  все  совпадения,  нужно  использовать  для  поиска  не  строку  "-",  а регулярное выражение /-/g, причём обязательно с флагом g:
		alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56
		$$  Вставляет "$".
		$&  Вставляет всё найденное совпадение.
		$`  Вставляет часть строки до совпадения.
		$'  Вставляет часть строки после совпадения. 
		$*n*  где n -- цифра или двузначное число, обозначает n-ю по счёту скобку, если считать слева-направо.
		...
		var str = "Василий Пупкин";
		alert(str.replace(/(Василий) (Пупкин)/, '$2, $1')) // Пупкин, Василий 
		...
		Ещё пример, с использованием $&: 
		var str = "Василий Пупкин";
		alert(str.replace(/Василий Пупкин/, 'Великий $&!')) // Великий Василий Пупкин!
		...
		Для ситуаций, которые требуют максимально «умной» замены, в качестве второго аргумента предусмотрена функция.
		var i = 0; 
		// заменить каждое вхождение "ой" на результат вызова функции
		alert("ОЙ-Ой-ой".replace(/ой/gi, function() {  return ++i;}));
		// 1-2-3
		В примере выше функция просто возвращала числа по очереди, но обычно она основывается на поисковых данных. 
			Эта функция получает следующие аргументы: 
			1.  str – найденное совпадение, 
			2.  p1, p2, ..., pn – содержимое скобок (если есть), 
			3.  offset – позиция, на которой найдено совпадение, 
			4.  s – исходная строка.
		...
		replacer(str, offset, s) - Если скобок в регулярном выражении нет, то у функции всегда будет ровно 3 аргумента
		// вывести и заменить все совпадения 
		function replacer(str, offset, s)  
			{ alert( "Найдено: " + str + " на позиции: " + offset + " в строке: " + s ); 
			return str.toLowerCase(); 
			} 
		var result = "ОЙ-Ой-ой".replace(/ой/gi, replacer); 
		alert( 'Результат: ' + result ); // Результат: ой-ой-ой
		С двумя скобочными выражениями – аргументов уже 5: 
		function replacer(str, name, surname, offset, s)  
		{ 
		  return surname + ", " + name; 
		} 
		var str = "Василий Пупкин"; 
		alert(str.replace(/(Василий) (Пупкин)/, replacer)) // Пупкин, Василий
		
		
		
		regexp.test(str) - проверяет,  есть  ли  хоть  одно  совпадение  в  строке  str.  Возвращает true/false.
		...
		var str = "Люблю регэкспы я, но странною любовью"; 
		// эти две проверки идентичны 
		alert( /лю/i.test(str) ) // true 
		alert( str.search(/лю/i) != -1 ) // true
		...
		var str = "Ой, цветёт калина..."; 
		alert( /javascript/i.test(str) ) // false 
		alert( str.search(/javascript/i) != -1 ) // false
		
		
		regexp.exec(str) - Метод regexp.exec дополняет их. Он позволяет искать и все совпадения и скобочные группы в них. 
			search – ищет индекс 
			match – если регэксп без флага g – ищет совпадение с подрезультатами в скобках 
			match – если регэксп с флагом g – ищет все совпадения, но без скобочных групп. 
		Если флага g нет, то regexp.exec(str) ищет и возвращает первое совпадение, является полным аналогом вызова str.match(reg)
		Если флаг g есть, то вызов regexp.exec возвращает первое совпадение и запоминает его позицию в свойстве regexp.lastIndex. Последующий поиск он начнёт уже с этой позиции. Если совпадений не найдено, то сбрасывает regexp.lastIndex в ноль.		
		</pre>
	</details>
	<br>
	
	
	<details>
		<summary><b>Лекция ООП</b></summary>
		<pre>
		person = new Object ();
		person = {}; // Порожні фігурні дужки
		
		Наповнюємо об'єкт властивостями
		person.name = 'Вася';
		person.age = 25;
		peron['name'];
		
		------------------------------------------
		
		var user {
			name: "Andrey",
			age: 41
		};
		
		--------------------------------
		
		let obj = {
			0: "Тест" // те саме, що і "0": "Тест". якщо використовувати як ключ число 0, то воно перетвориться на рядок "0":
		};

		----------------------------------------
		let user = {};
		user.noSuchProperty === undefined; //Особливість об'єктів у тому, що можна отримати доступ до будь-якої якості. Навіть якщо властивості не існує – помилок не буде! При зверненні до властивості, якої немає, повертається undefined . Це дозволяє просто перевірити існування властивості – порівнянням його з undefined
		
		user.year = 1999;
		"year" in user; // true
		
		-----------------------------------------------
		var menu = {
			width: 300,
			height: 200,
			title: "Menu"
		};
		for ( var key in menu)
			document.write ( " Ключ : " + key + " значення : " + menu[key] + ” ) 
		
		-------------------------------------------------------------------
		
		var user = {
		  name : "Вася"
		};
	
		var admin = user; // Скопіювали посилання
		
		
		-------------------------- Методи об'єктів
		var user = {
			name : 'Василь’,
			// метод
			sayHi : function () {
			// властивості присвоюється
			alert ( 'Привіт!' ); // Посилання на анонімну функцію
			}
		};

		// Виклик
		user.sayHi ();
		
		----------------
		var user = {
			name : 'Василь'
		};
 
		//Привласнили метод після створення об'єкта
		user.sayHi = function () { 
			alert ('Привіт!');
		};
 
		// Виклик методу:
		user.sayHi();

		-------------------------- Об'єкти-константи
		const user = {
			name: "John"
		};

		user.age = 25; // сам об'єкт міняти можна
		alert( user.age ); // 25

		user = {name: "Pete" }; // а ось посилання міняти не можна!!!!!!!!
		
		------------------------------------------------------------
		
		Object.assign ( dest , [src1, src2, src3 ...])
		Аргументи dest і src1, ..., srcN (можливо стільки, скільки потрібно) є об'єктами.
		
		не робить глибоке клонування!
		let user = {
			name: "John",
			sizes: {
				height: 182,
				width: 50
			}
		};
		
		let clone = Object.assign ({}, user);
		user і clone звертаються до одного sizes

		------------------------------------------------------------
		
		Object.defineProperty ( obj, propertyName, descriptor ) // Створення нового властивості
		Object.getOwnPropertyDescriptor ( obj, propertyName ); // Отримання дескриптора властивості
		-----------------------
		
		Дескриптори властивостей- аксесорів відрізняються від «звичайних» властивостей-даних.
		Властивості -аксесори не мають value і writable , але натомість пропонують функції get і set .
		Тобто , дескриптор аксесору може мати:
		set — функція, яка приймає один параметр — значення, яке задається під час присвоєння значення властивості. Використовується для налаштування значення або виконання певних дій під час присвоєння значення.
		get — функція без параметрів, яка викликається під час доступу до властивості. Використовується для отримання значення, що обчислюється на основі іншої логіки.
		value — значення, яке зберігається в властивості.
		writable — визначає, чи можна змінювати значення цієї властивості. Якщо writable: true, значення властивості можна змінити, якщо writable: false, властивість буде лише для читання.
		enumerable — визначає, чи буде властивість відображатися в циклі for...in або методах типу Object.keys().
		configurable — визначає, чи можна змінювати характеристики властивості або видалити її. Якщо configurable: false, то змінити дескриптор або видалити властивість буде неможливо.
		
		const person = {};

		Object.defineProperty(person, 'name', {
			get() {
				return this._name;
			},
			set(value) {
				this._name = value.trim(); // автоматично обрізаємо пробіли
			},
			enumerable: true,
			configurable: true
		});

		person.name = '   John Doe   ';
		console.log(person.name); // "John Doe"
		
		---------------
		
		let user = {
			name: "John",
			surname: "Smith",
			get fullName () {
				return `${this.name} ${ this.surname }`;
			},
			set fullName (value) {
				let tmp = value.split (' ', 2);
				this.name = tmp [0];
				this.surname = tmp [1];
				//[this.name, this.surname ] = value.split (" "); // або 
			}
		};

		alert( user.fullName ); // John Smith
		
		user.fullName = "Ivan Petrov ";
		alert(user.name + "-" + user.surname ); // Ivan - Petrov
		---------
		Властивості об'єкта може бути або властивістю- аксесором (з методами get / set ), або властивістю-даним (зі значенням value ).
		При спробі вказати і get , і value в одному дескрипторі буде помилка
		------
		
		let user = {};
		Object.defineProperty (user, "name", {
			value: "John",
			// для нового властивості необхідно явно вказувати всі прапори, котрим значення true
			writeble : false,
			enumerable: true,
			configurable: true
		});

		alert(user.name); // John
		user.name = "Pete"; // Помилка т.к. Writeble = false




		
		
		
		</pre>
		
		<script>
			let person = new Object();
			person.name = 'Andrey';
			person.age = 41;
			
			console.log(person);
			
			person.age = 42;
			person[0] = 0;
			console.log(person, person['name'],);
			//------------------------------------------
			
			var user = {				
				name: "Andrey",
				age: 41
			};
			
			user.obj = user instanceof Object;
			user.date = new Date();
			
			console.log(user);
			
			
			var users = [
				{ name: " Вася ", age: 25 },
				{ name: " Петя ", age: 22 },
				{ name : "Маша", age : 19 }
			];
			
			for (let user of users) {
				console.log(user)
			}
			
			
			function makeUser (name, age) {
				return {
					type: 'function',
					//name: name,
					name, // те саме, що й name: name
					age: age
				};
			}
			let fuser = makeUser("John", 30);
			console.log(fuser); // John
				
			// ----------------------------------
			var user = {
				name : "Вася"
			};
			
			var admin = user; // Создание ссылки
			console.log(user, admin);
			
			user.name = 'Коля';
			console.log(user, admin);

			//----------------------------------
			
			var user = {
				name: 'Andrey',
				year: 1984
			}
			
			var user_clone = {};
			for ( var key in user) {
				user_clone[key] = user[key];
			}
			console.log(user, user_clone);
			
			var user_clone2 = {... user};
			user_clone2['name'] = 'AZ'
			
			var user_clone3 = Object.assign({}, user_clone2);
			user_clone3.year += 1000;
			
			console.log(user, user_clone2, user_clone3);
			
			//-------------------------------------------
			
			var user = {
				name : 'Василь',
				// метод
				sayHi : function () {
				// властивості присвоюється
				console.log( 'Посилання на анонімну функцію' ); // Посилання на анонімну функцію
				}
			};

			// Виклик
			user.sayHi();			
			//-------------
			var user = {
			  name : 'Василь'
			};
			 
			//Привласнили метод після створення об'єкта
			user.sayHi = function() { 
				console.log('Привласнили метод після створення об\'єкта');
			};
			 
			// Виклик методу:
			user.sayHi();
			//-------------------------------------------
			
			var user = {
				name: 'User',
				func: function() {
					console.log(`Hello ${this.name}`)
				}
			};
			
			user.func();
			
			
			///-------------------------------------------
			
			const person2 = {};

			Object.defineProperty(person2, 'name', {
				value: 'John Doe',
				enumerable: true,   // властивість буде перераховуватися
				configurable: false  // можна змінювати дескриптор властивості
			});
			console.log('person2', Object.keys(person2)); // ['name']

			// Змінимо enumerable
			Object.defineProperty(person2, 'name', {
				enumerable: true
			});
			console.log('person2', Object.keys(person2)); // []

		
		</script>		
	</details>
	<br>
	
	
	<details>
		<summary><b>Функції та області видимості. this в методах. Об'єкти LexicalEnvironment. Порядок доступу до змінних. Замикання</b></summary>
		
		<pre>
			var user = {
				name: 'Василь',
				// метод
				sayHi: function() { // властивості присвоюється
					alert( 'Привіт!'); 
				} // Посилання на анонімну функцію
			};
			
			Це посилання, тому можна присвоювати, замінювати та видаляти
			
			//Привласнили метод після створення об'єкта
			user.sayHi = function() {
				alert('Привіт!');
			};
			
			user.sayHi = null;
			user.sayHi(); // Помилка
			
			-------------------------------------------
			
			Доступ до об'єкту через this
			var user = { name: ' Василь',
				sayHi: function() {
					alert(this.name);
				}
			};
			==============================================================================================
			<h3>Значенням this є об'єкт перед «точкою», у якого викликаний метод</h3>
			Абсолютно неважливо, оголошено її в об'єкті або окремо від нього. Значення this називається контекстом виклику і буде визначено у момент виклику функції.
			Якщо функція використовує this - Це передбачає роботу з об'єктом. Але і прямий виклик func() технічно можливе.
			
			При цьому this отримує значення window або глобального об'єкта:
			function func() {
				alert(this);
			}

			func();  // виведе [ object Window] або [ object global]
			
			А в режимі  use strict замість глобального об'єкту this буде undefined
			==============================================================================================
			
			var room = {
				number: 777,
				valueOf: function() {
					return this.number;    
				},
				toString: function() {
					return this.number;
				}
			};

			alert(+room);
			
			то здесь происходит
			room — это объект, у которого есть:
				свойство number со значением 777
				методы valueOf() и toString()
			Оператор + перед объектом (+room) — это унарный плюс.
				Он пытается преобразовать значение к числу.
			При числовом преобразовании объекта JavaScript действует так:
				сначала вызывает метод valueOf()
				если он возвращает примитив (число, строку и т.п.) — использует его
				если нет — вызывает toString()

			Глобальними називають змінні та функції, які не знаходяться всередині якоїсь функції.
			У JavaScript усі глобальні змінні та функції є властивостями спеціального об'єкта, який називається « глобальний об'єкт» (global object).
			У браузері цей об'єкт явно доступний під назвою window.
			================================================================================
			

			<h3>Лексичне оточення</h3>
			<b></u>LexicalEnvironment</u></b> - Усі змінні всередині функції – це властивості спеціального внутрішнього об'єкта LexicalEnvironment, що створюється під час її запуску.
			При запуску функція створює об'єкт LexicalEnvironment, записує туди аргументи, функції та змінні.
			На відміну від window, об'єкт LexicalEnvironment є внутрішнім, він прихований від прямого доступу
			================================================================================
			
			Вкладені функції
			
			function A() {
				var a = 1;
				B();
			  
				function B() {
					var b = 2;
					C();
			 
					function C() {
						var c = 3;
						alert(' ' + gl + ' ' + a + ' ' + b + ' ' + c);
					}
				}   
			}

			var gl = 0;
			A();
			
			В JavaScript используется лексическая область видимости — вложенные функции видят переменные внешних функций, но не наоборот.
			Почему это работает: Потому что функция C имеет доступ ко всем внешним областям видимости: C → B → A → global
			
			Лексичні оточення вистоюються в список (ланцюжок):
			Інтерпретатор при доступі до змінної спочатку намагається знайти змінну в поточному LexicalEnvironment , а потім, якщо її немає - шукає в батьківському оточенні
			Пошук повторюється доки змінна не знайдена чи ні батьківського оточення
			При створенні функція отримує приховану властивість <b><u>Scope</b></u>, яка посилається на лексичне оточення, в якому вона була створена.
			================================================================================
			
			Фабрична функція
			
			function makeCounter() {
				var currentCount = 1;

				return function() { // (**)
					return currentCount++;
				};
			}
			
			var counter = makeCounter();

			counter(); // 1
			counter(); // 2
			counter(); // 3

			================================================================================
			function f() {
				//будь-яке тіло функції
			}
			f.test = 5;
			alert(f.test);
			
			Відмінності властивостей від параметрів та локальних змінних
			- Змінні доступні лише усередині функції, створюються у процесі виконання.
			- C властивість функції – доступна звідусіль і завжди. Це використання функції «як об'єкта».
			- Якщо хочеться прив'язати значення до функції, можна скористатися ним замість зовнішніх (статичних) змінних.

			================================================================================
			Лічильник через властивість ф-ії
			
			function makeCounter() {
			  function counter() {
				return counter.currentCount++;
			  };
			  counter.currentCount = 1;
			  return counter;
			}
			---------------------------------
			
			function makeCounter() {
			  var currentCount = 1;

			  // Возвращаемая функция
			  function counter() {
				return currentCount++;
			  }

			  // метод установки значения
			  counter.set = function(value) {
				currentCount = value;
			  };

			  // метод сброса
			  counter.reset = function() {
				currentCount = 1;
			  };

			  return counter;
			}

			
			






		
		</pre>
		
		<script>
			function makeCounter() {
				var currentCount = 1;

				return function() { // (**)
					return currentCount++;
				};
			}
			
			var counter = makeCounter();

			for (let i = 0; i < 3; i++) {
				console.log('counter 1: ', i, counter());
			}
			
			var counter2 = makeCounter();
			for (let i = 0; i < 3; i++) {
				console.log('counter 2: ', i, counter2());
			}
			
			var counter3 = makeCounter();
			counter3.currentCount = 10;
			console.log('counter3=', counter3.currentCount);
			console.log('counter 3: ', counter3());
			//---------------
			
			function makeCounter2() {
				let currentCount = 1;

				function counter() {
					return currentCount++;
				}

				counter.set = function(value) {
					currentCount = value;
				};

			return counter;
		}

		var counter4 = makeCounter2();
		counter4.set(10);
		for (let i = 0; i < 3; i++) {
				console.log('counter 4: ', i, counter4());
		}
			
			
		
		</script>
		
		
	</details>
	
</body>
</html>
